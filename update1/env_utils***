///* ************************************************************************** */
///*                                                                            */
///*                                                        :::      ::::::::   */
///*   env_utils.c                                        :+:      :+:    :+:   */
///*                                                    +:+ +:+         +:+     */
///*   By: husarpka <husarpka@student.42.fr>          +#+  +:+       +#+        */
///*                                                +#+#+#+#+#+   +#+           */
///*   Created: 2025/07/31 00:00:00 by mertilhan13       #+#    #+#             */
///*   Updated: 2025/08/03 21:26:19 by husarpka         ###   ########.fr       */
///*                                                                            */
///* ************************************************************************** */

//#include "shell.h"
//#include <stdlib.h>
//#include <string.h>

//t_env *find_env(t_env *env_list, const char *key) 
//{
//    t_env *current;
    
//    if (!env_list || !key)
//        return NULL;
    
//    current = env_list;
//    while (current)
//    {
//        if (ft_strcmp(current->key, key) == 0)
//            return current;
//        current = current->next;
//    }
//    return NULL;
//}

////t_env *init_env(char **env)
////{
////    t_env *env_list = NULL;
////    t_env *new_node;
////    char *key;
////    char *value;
////    char *eq_pos;
////    int i;
    
////    i = 0;
////    while(env[i])
////    {
////        eq_pos = ft_strchr(env[i], '=');
////        if(eq_pos)
////        {
////            key = ft_strndup(env[i], eq_pos - env[i]);
////            value = ft_strdup(eq_pos + 1);
////            new_node = env_gb_malloc(sizeof(t_env));
////            new_node->key = key;
////            new_node->value = value;
////            new_node->next = env_list;
////            env_list = new_node;
////        }
////        i++;
////    }
////    return(env_list);
////}

//char *get_env_value(t_env *env_list, char *key)
//{
//    t_env *env_variable = find_env(env_list, key);
//    if (env_variable)
//        return env_variable->value;
//    return NULL;
//}

//void set_env_value(t_env **env_list, char *key, char *value)
//{
//    if (!env_list) {
//        return;
//    }
    
//    t_env *existing = find_env(*env_list, key);
    
//    if (existing)
//    {
//        free(existing->value);
//        existing->value = ft_strdup(value);
//    }
//    else
//    {
//        t_env *new_node = env_gb_malloc(sizeof(t_env));
//        if (!new_node)
//        {
//            perror("malloc failed");
//            return;
//        }
//        new_node->key = ft_strdup(key);
//        new_node->value = ft_strdup(value);
//        new_node->next = *env_list;
//        *env_list = new_node;
//    }
//}

//void unset_env_value(t_env **env_list, char *key)
//{
//    if (!env_list || !*env_list || !key)
//        return;
        
//    t_env *current = *env_list;
//    t_env *prev = NULL;
    
//    while (current)
//    {
//        if (ft_strcmp(current->key, key) == 0)
//        {
//            if (prev)
//                prev->next = current->next;
//            else
//                *env_list = current->next;
            
//            free(current->key);
//            free(current->value);
//            free(current);
//            return;
//        }
//        prev = current;
//        current = current->next;
//    }
//}

//// Function to free environment list
//void free_env_list(t_env *env_list)
//{
//    t_env *current = env_list;
//    t_env *next;
    
//    while (current)
//    {
//        next = current->next;
//        if (current->key)
//            free(current->key);
//        if (current->value)
//            free(current->value);
//        free(current);
//        current = next;
//    }
//}

//// Function to convert env list to array for execve
//char **env_list_to_array(t_env *env_list)
//{
//    int count = 0;
//    t_env *current = env_list;
    
//    // Count entries
//    while (current)
//    {
//        if (current->value) // Only include entries with values
//            count++;
//        current = current->next;
//    }
    
//    char **env_array = gb_malloc(sizeof(char *) * (count + 1));
//    if (!env_array)
//        return (NULL);
    
//    int i = 0;
//    current = env_list;
//    while (current && i < count)
//    {
//        if (current->value)
//        {
//            int len = strlen(current->key) + strlen(current->value) + 2; // +2 for '=' and '\0'
//            env_array[i] = gb_malloc(len);
//            if (!env_array[i])
//            {
//                int j = 0;
//                while (j < i)
//                {
//                    free(env_array[j]);
//                    j++;
//                }
//                free(env_array);
//                return (NULL);
//            }
//            strcpy(env_array[i], current->key);
//            strcat(env_array[i], "=");
//            strcat(env_array[i], current->value);
//            i++;
//        }
//        current = current->next;
//    }
//    env_array[i] = NULL;
//    return (env_array);
//}

//// Export list functions
//t_export *find_export(t_export *export_list, const char *key)
//{
//    t_export *current = export_list;
    
//    while (current)
//    {
//        if (ft_strcmp(current->key, key) == 0)
//            return current;
//        current = current->next;
//    }
//    return NULL;
//}

//void set_export_value(t_export **export_list, const char *key, const char *value)
//{
//    t_export *existing = find_export(*export_list, key);
    
//    if (existing)
//    {
//        if (existing->value)
//            free(existing->value);
//        if (value)
//            existing->value = ft_strdup((char*)value);
//        else
//            existing->value = NULL;
//    }
//    else
//    {
//        t_export *new_export = env_gb_malloc(sizeof(t_export));
//        if (!new_export)
//            return;
        
//        new_export->key = ft_strdup((char*)key);
//        if (value)
//            new_export->value = ft_strdup((char*)value);
//        else
//            new_export->value = NULL;
//        new_export->next = *export_list;
//        *export_list = new_export;
//    }
//}

//void unset_export_value(t_export **export_list, const char *key)
//{
//    t_export *current = *export_list;
//    t_export *prev = NULL;
    
//    while (current)
//    {
//        if (ft_strcmp(current->key, key) == 0)
//        {
//            if (prev)
//                prev->next = current->next;
//            else
//                *export_list = current->next;
            
//            if (current->key)
//                free(current->key);
//            if (current->value)
//                free(current->value);
//            free(current);
//            return;
//        }
//        prev = current;
//        current = current->next;
//    }
//}

//void free_export_list(t_export *export_list)
//{
//    t_export *current = export_list;
//    t_export *next;
    
//    while (current)
//    {
//        next = current->next;
//        if (current->key)
//            free(current->key);
//        if (current->value)
//            free(current->value);
//        free(current);
//        current = next;
//    }
//}

//char *find_export_value(char *key)
//{
//    t_export **export_list = get_export_list();
//    t_export *current = *export_list;
    
//    while (current)
//    {
//        if (ft_strcmp(current->key, key) == 0 && current->value)
//            return current->value;
//        current = current->next;
//    }
//    return NULL;
//}

////t_export *init_export_from_env(t_env *env_list)
////{
////    t_export *export_list = NULL;
////    t_env *current = env_list;
    
////    while (current)
////    {
////        set_export_value(&export_list, current->key, current->value);
////        current = current->next;
////    }
    
////    return export_list;
////}
